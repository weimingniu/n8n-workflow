{"createdAt":"2025-08-01T10:40:06.339Z","updatedAt":"2025-08-15T07:16:11.323Z","id":"KrTBoSiuQw3EYkL7","name":"support-knowledge-ingestion","active":true,"isArchived":false,"nodes":[{"parameters":{"rule":{"interval":[{"daysInterval":7}]}},"type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.2,"position":[-800,20],"id":"89e89c97-8e71-4d8c-b9f2-e6ae151b3af1","name":"Update Knowledge Cron"},{"parameters":{"url":"https://api.intercom.io/articles","authentication":"predefinedCredentialType","nodeCredentialType":"intercomApi","sendQuery":true,"queryParameters":{"parameters":[{"name":"per_page","value":"200"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[300,-80],"id":"122414c9-1505-418f-8f3c-2d90dd497487","name":"Get Articles from Intercom","credentials":{"intercomApi":{"id":"Qo33N6yHJ87JjI7K","name":"Intercom account"}}},{"parameters":{"mode":"insert","pineconeIndex":{"__rl":true,"value":"n8n-support-workflow","mode":"list","cachedResultName":"n8n-support-workflow"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStorePinecone","typeVersion":1.3,"position":[760,20],"id":"c166979f-979b-4b12-9cbe-56d5b826db28","name":"Pinecone Vector Store","credentials":{"pineconeApi":{"id":"Dqkxk7RFy3FsQZe8","name":"PineconeApi account for support workflow"}}},{"parameters":{"model":"text-embedding-3-large","options":{"dimensions":1024,"batchSize":30}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[700,240],"id":"0ecee326-d4bc-4f7d-8b44-e55795cc7c07","name":"Embeddings OpenAI","credentials":{"openAiApi":{"id":"iPu6knDrJFJxLQSO","name":"OpenAI account for support"}}},{"parameters":{"jsCode":"/**\n * Remove HTML tags and clean up text content.\n * \n * @param {string} htmlText - HTML content to clean\n * @returns {string} Cleaned text without HTML tags\n */\nfunction cleanHtml(htmlText) {\n  if (!htmlText) {\n      return \"\";\n  }\n  \n  // Remove HTML tags\n  let cleanText = htmlText.replace(/<[^>]+>/g, '');\n  \n  // Decode HTML entities\n  const htmlEntities = {\n      '&amp;': '&',\n      '&lt;': '<',\n      '&gt;': '>',\n      '&quot;': '\"',\n      '&#x27;': \"'\",\n      '&#x2F;': '/',\n      '&nbsp;': ' '\n  };\n  \n  for (const [entity, replacement] of Object.entries(htmlEntities)) {\n      cleanText = cleanText.replaceAll(entity, replacement);\n  }\n  \n  // Clean up whitespace\n  cleanText = cleanText.replace(/\\s+/g, ' ');\n  cleanText = cleanText.trim();\n  \n  return cleanText;\n}\n\n/**\n* Split text into overlapping chunks for better retrieval.\n* Optimized for 512-dimension embeddings with smaller chunk sizes.\n* \n* @param {string} text - Text to chunk\n* @param {number} chunkSize - Maximum size of each chunk (default: 400)\n* @param {number} overlap - Number of characters to overlap between chunks (default: 50)\n* @returns {string[]} Array of text chunks\n*/\nfunction chunkText(text, chunkSize = 1000, overlap = 100) {\n  if (text.length <= chunkSize) {\n      return [text];\n  }\n  \n  const chunks = [];\n  let start = 0;\n  \n  while (start < text.length) {\n      let end = start + chunkSize;\n      \n      // If this isn't the last chunk, try to break at a sentence or word boundary\n      if (end < text.length) {\n          // Look for sentence boundary\n          const sentenceBreak = text.lastIndexOf('.', end);\n          if (sentenceBreak > start + Math.floor(chunkSize / 2)) {\n              end = sentenceBreak + 1;\n          } else {\n              // Look for word boundary\n              const wordBreak = text.lastIndexOf(' ', end);\n              if (wordBreak > start + Math.floor(chunkSize / 2)) {\n                  end = wordBreak;\n              }\n          }\n      }\n      \n      const chunk = text.slice(start, end).trim();\n      if (chunk) {\n          chunks.push(chunk);\n      }\n      \n      // Move start position with overlap\n      start = end - overlap;\n      if (start >= text.length) {\n          break;\n      }\n  }\n  \n  return chunks;\n}\n\n/**\n* Clean and format a single article for Pinecone ingestion.\n* Optimized for 512-dimension embeddings.\n* \n* @param {Object} article - Raw article data\n* @returns {string[]} Array of formatted chunks as JSON strings ready for embedding\n*/\nfunction cleanArticleForPinecone(article) {\n  // Extract and clean basic fields\n  const articleId = String(article.id || '');\n  const title = (article.title || '').trim();\n  const description = (article.description || '').trim();\n  const body = cleanHtml(article.body || '');\n  const url = article.url || '';\n  \n  // Combine title, description, and body for full content\n  const fullContent = [];\n  if (title) {\n      fullContent.push(`Title: ${title}`);\n  }\n  if (description) {\n      fullContent.push(`Description: ${description}`);\n  }\n  if (body) {\n      fullContent.push(`Content: ${body}`);\n  }\n  \n  const combinedText = fullContent.join('\\n\\n');\n  \n  // Skip empty articles\n  if (!combinedText.trim()) {\n      return [];\n  }\n  \n  // Create text chunks optimized for 512-dimension embeddings (smaller chunks)\n  const chunks = chunkText(combinedText, 1000, 100);\n  \n  // Format each chunk for Pinecone and stringify\n  const formattedChunks = [];\n  \n  chunks.forEach((chunk, i) => {\n      // Create unique ID for each chunk\n      const chunkId = `${articleId}_chunk_${i}`;\n      \n      // Prepare metadata (compact for 512-dimension constraints)\n      let metadata = {\n          article_id: articleId,\n          title: title,\n          description: description,\n          url: url,\n          chunk_index: i,\n          total_chunks: chunks.length\n      };\n      \n      // Remove empty string values to reduce metadata size\n      metadata = Object.fromEntries(\n          Object.entries(metadata).filter(([key, value]) => value !== '' && !Array.isArray(value) || (Array.isArray(value) && value.length > 0))\n      );\n      \n      const formattedChunk = {\n          id: chunkId,\n          chunk_text: chunk,\n          metadata: metadata\n      };\n      \n      // Stringify the chunk object for embedding\n      formattedChunks.push(formattedChunk);\n  });\n  \n  return formattedChunks;\n}\n\n/**\n* Process the entire dataset and prepare it for Pinecone ingestion.\n* Optimized for 512-dimension embeddings.\n* \n* @param {Object[]} data - Array of raw article data\n* @returns {string[]} Array of all processed chunks as JSON strings ready for embedding\n*/\nfunction processDataForPinecone(data) {\n  const allChunks = [];\n  let processedCount = 0;\n  let skippedCount = 0;\n  \n  // Process each article\n  data.forEach(article => {\n      try {\n          const chunks = cleanArticleForPinecone(article);\n          if (chunks.length > 0) {\n              allChunks.push(...chunks);\n              processedCount++;\n              console.log(`Processed article ${article.id || 'unknown'}: ${chunks.length} chunks`);\n          } else {\n              skippedCount++;\n              console.log(`Skipped empty article ${article.id || 'unknown'}`);\n          }\n      } catch (error) {\n          skippedCount++;\n          console.log(`Error processing article ${article.id || 'unknown'}: ${error.message}`);\n      }\n  });\n  \n  console.log(`\\nProcessing complete (optimized for 512-dimension embeddings):`);\n  console.log(`- Processed articles: ${processedCount}`);\n  console.log(`- Skipped articles: ${skippedCount}`);\n  console.log(`- Total chunks created: ${allChunks.length}`);\n  \n  return allChunks;\n}\n\nlet data = processDataForPinecone($input.first().json.data)\n\nreturn data"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[520,-80],"id":"0b58e977-0e8d-4a24-992d-764cbb102e3f","name":"Clean Article Data"},{"parameters":{"chunkOverlap":100,"options":{}},"type":"@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter","typeVersion":1,"position":[940,440],"id":"2b43e14b-41df-4db1-b4f9-96d13a3d038e","name":"Recursive Character Text Splitter"},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.chatTrigger","typeVersion":1.1,"position":[-800,680],"id":"fe0cd4e5-1f3b-42a5-ada2-3a79af504b39","name":"When chat message received","webhookId":"753ce490-9a7a-44c0-addf-6c5cbd1d5267"},{"parameters":{"options":{"systemMessage":"You are a helpful assistant providing answers for user support tickets for Meshy AI (www.meshy.ai). Get information of real help center articles from vector database. If you can't get accurate information, don't answer."}},"type":"@n8n/n8n-nodes-langchain.agent","typeVersion":2,"position":[-540,680],"id":"bd95c621-7bbd-489e-8b4b-48415c357f14","name":"AI Agent"},{"parameters":{"model":{"__rl":true,"value":"gpt-4.1","mode":"list","cachedResultName":"gpt-4.1"},"options":{}},"type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.2,"position":[-580,900],"id":"58734266-1154-4156-b2c3-8d6adc65f6f1","name":"OpenAI Chat Model","credentials":{"openAiApi":{"id":"iPu6knDrJFJxLQSO","name":"OpenAI account for support"}}},{"parameters":{},"type":"@n8n/n8n-nodes-langchain.memoryBufferWindow","typeVersion":1.3,"position":[-460,900],"id":"a466f8a8-1d65-444e-b116-4eb468bd6078","name":"Simple Memory"},{"parameters":{"mode":"retrieve-as-tool","toolDescription":"Get information from Meshy's help center, api docs and etc. from vector database.","pineconeIndex":{"__rl":true,"value":"n8n-support-workflow","mode":"list","cachedResultName":"n8n-support-workflow"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStorePinecone","typeVersion":1.3,"position":[-340,902.5],"id":"222041d3-a55c-4321-979b-6347dd1276bb","name":"Pinecone Vector Store Tool","credentials":{"pineconeApi":{"id":"Dqkxk7RFy3FsQZe8","name":"PineconeApi account for support workflow"}}},{"parameters":{"model":"text-embedding-3-large","options":{"dimensions":1024}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[-260,1100],"id":"91a47c78-2ec7-4f6b-9d2f-7ca0b6769799","name":"Embeddings OpenAI1","credentials":{"openAiApi":{"id":"iPu6knDrJFJxLQSO","name":"OpenAI account for support"}}},{"parameters":{"jsonMode":"expressionData","jsonData":"={{ $json.chunk_text }}","textSplittingMode":"custom","options":{"metadata":{"metadataValues":[{"name":"article_id","value":"={{ $json.metadata.article_id }}"},{"name":"=title","value":"={{ $json.metadata.title }}"},{"name":"url","value":"={{ $json.metadata.url }}"},{"name":"chunk_index","value":"={{ $json.metadata.chunk_index }}"},{"name":"total_chunks","value":"={{ $json.metadata.total_chunks }}"},{"name":"path","value":"={{ $json.metadata.path }}"}]}}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1.1,"position":[860,240],"id":"aa90d682-d4e5-4722-90a2-944a75743027","name":"Default Data Loader"},{"parameters":{"content":"- Intercom Macro data link: https://app.intercom.com/ember/saved_replies.json?app_id=ipvgg8in\n\n- Pinecore vector database link: https://app.pinecone.io/organizations/-OXbiJBlnvYgxtg12Sw7/projects/004dc4e6-0869-471b-91a0-74aa371fa18a/indexes/n8n-support-workflow/browser\n\n- Pinecone uses team@meshy.ai Google OAuth login","height":380},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[-1060,-120],"id":"f3b0127b-8bbe-4cdb-a65c-6ea6a3b17c60","name":"Sticky Note"},{"parameters":{"assignments":{"assignments":[{"id":"e99af80d-f231-45eb-868f-5b15c2bab285","name":"owner","value":"taichi-dev","type":"string"},{"id":"3c7d0611-cf6e-4ab5-8885-a82591bdf730","name":"repo","value":"meshy-portals","type":"string"},{"id":"c4a675be-d57c-4776-803d-f798ee7d16e3","name":"folder","value":"meshy-docs/src/app/[locale]","type":"string"},{"id":"267d1376-beab-425c-84f8-af6dc2861829","name":"ref","value":"main","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-580,120],"id":"db4e2847-d6d4-411c-9130-1317bb1d2fea","name":"Github Repo Info"},{"parameters":{"url":"=https://api.github.com/repos/{{$json.owner}}/{{$json.repo}}/git/trees/{{$json.ref}}?recursive=1","authentication":"predefinedCredentialType","nodeCredentialType":"githubApi","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-360,120],"id":"e2178c16-11f7-4dff-9ecc-5f33589c2f34","name":"Get Github Repo","credentials":{"githubApi":{"id":"FqtIXCoaqmPbSLRQ","name":"GitHub for support workflow"}}},{"parameters":{"jsCode":"const folder = $('Github Repo Info').first().json.folder.replace(/^\\/+|\\/+$/g, '');\nconst prefix = folder.length ? folder + '/' : '';\nconst tree = $input.first().json.tree || [];\nconst files = tree.filter(n => n.type === 'blob' && n.path.startsWith(prefix));\nreturn files.map(f => ({ json: f }));"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-140,120],"id":"a2b95cbc-11e8-4b59-90cf-6213a8d53f3e","name":"Get All Files"},{"parameters":{"url":"=https://api.github.com/repos/{{ $('Github Repo Info').item.json.owner }}/{{ $('Github Repo Info').item.json.repo }}/contents/{{$json.path}}?ref={{ $('Github Repo Info').item.json.ref }}","authentication":"predefinedCredentialType","nodeCredentialType":"githubApi","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[80,120],"id":"f263566b-53ab-4dea-a58d-b1e79e21b9dc","name":"Get File Content","credentials":{"githubApi":{"id":"FqtIXCoaqmPbSLRQ","name":"GitHub for support workflow"}}},{"parameters":{"jsCode":"// Process all items and combine into a single array\nconst allFiles = items.map(i => {\n  // 兼容 Contents/Blob 两种返回\n  const isContents = 'content' in i.json || 'download_url' in i.json;\n  const path = i.json.path || i.json.url?.split('/git/blobs/')[0]; // 尽量还原\n  let text;\n  if (isContents && i.json.content && i.json.encoding === 'base64') {\n    text = Buffer.from(i.json.content, 'base64').toString('utf8');\n  } else if (typeof i.json === 'string') {\n    // Blob raw 模式时，i.json 可能直接是字符串\n    text = i.json;\n  } else {\n    // 尝试兼容\n    text = i.json.data || '';\n  }\n  return { path, text };\n});\n\nreturn { allFiles };"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[300,120],"id":"21c11bf0-94b6-4b9c-8256-aff9b58e64d5","name":"Reformat Files"},{"parameters":{"jsCode":"/**\n * Remove HTML tags and clean up text content.\n * \n * @param {string} htmlText - HTML content to clean\n * @returns {string} Cleaned text without HTML tags\n */\nfunction cleanHtml(htmlText) {\n  if (!htmlText) {\n      return \"\";\n  }\n  \n  // Remove HTML tags\n  let cleanText = htmlText.replace(/<[^>]+>/g, '');\n  \n  // Decode HTML entities\n  const htmlEntities = {\n      '&amp;': '&',\n      '&lt;': '<',\n      '&gt;': '>',\n      '&quot;': '\"',\n      '&#x27;': \"'\",\n      '&#x2F;': '/',\n      '&nbsp;': ' '\n  };\n  \n  for (const [entity, replacement] of Object.entries(htmlEntities)) {\n      cleanText = cleanText.replaceAll(entity, replacement);\n  }\n  \n  // Clean up whitespace\n  cleanText = cleanText.replace(/\\s+/g, ' ');\n  cleanText = cleanText.trim();\n  \n  return cleanText;\n}\n\n/**\n* Split text into overlapping chunks for better retrieval.\n* Optimized for 1024-dimension embeddings with larger chunk sizes.\n* \n* @param {string} text - Text to chunk\n* @param {number} chunkSize - Maximum size of each chunk (default: 2000)\n* @param {number} overlap - Number of characters to overlap between chunks (default: 200)\n* @returns {string[]} Array of text chunks\n*/\nfunction chunkText(text, chunkSize = 2000, overlap = 200) {\n  if (text.length <= chunkSize) {\n      return [text];\n  }\n  \n  const chunks = [];\n  let start = 0;\n  \n  while (start < text.length) {\n      let end = start + chunkSize;\n      \n      // If this isn't the last chunk, try to break at a sentence or word boundary\n      if (end < text.length) {\n          // Look for sentence boundary\n          const sentenceBreak = text.lastIndexOf('.', end);\n          if (sentenceBreak > start + Math.floor(chunkSize / 2)) {\n              end = sentenceBreak + 1;\n          } else {\n              // Look for word boundary\n              const wordBreak = text.lastIndexOf(' ', end);\n              if (wordBreak > start + Math.floor(chunkSize / 2)) {\n                  end = wordBreak;\n              }\n          }\n      }\n      \n      const chunk = text.slice(start, end).trim();\n      if (chunk) {\n          chunks.push(chunk);\n      }\n      \n      // Move start position with overlap\n      start = end - overlap;\n      if (start >= text.length) {\n          break;\n      }\n  }\n  \n  return chunks;\n}\n\n/**\n* Clean and format a single article for Pinecone ingestion.\n* Optimized for 1024-dimension embeddings.\n* \n* @param {Object} article - Raw article data with 'path' and 'text' properties\n* @returns {Object[]} Array of formatted chunk objects ready for embedding\n*/\nfunction cleanArticleForPinecone(article) {\n  // Extract path and clean text content\n  const path = article.path || '';\n  const cleanText = cleanHtml(article.text || '');\n  \n  // Skip empty articles\n  if (!cleanText.trim()) {\n      return [];\n  }\n  \n  // Create text chunks optimized for 1024-dimension embeddings (larger chunks)\n  const chunks = chunkText(cleanText, 2000, 200);\n  \n  // Format each chunk for Pinecone\n  const formattedChunks = [];\n  \n  chunks.forEach((chunk, i) => {\n      // Create unique ID for each chunk using path\n      const chunkId = `${path.replace(/[^a-zA-Z0-9]/g, '_')}_chunk_${i}`;\n      \n      // Prepare metadata with only path\n      const metadata = {\n          path: path,\n          chunk_index: i,\n          total_chunks: chunks.length\n      };\n      \n      const formattedChunk = {\n          id: chunkId,\n          chunk_text: chunk,\n          metadata: metadata\n      };\n      \n      formattedChunks.push(formattedChunk);\n  });\n  \n  return formattedChunks;\n}\n\n/**\n* Process the entire dataset and prepare it for Pinecone ingestion.\n* Optimized for 1024-dimension embeddings.\n* \n* @param {Object[]} data - Array of raw article data with 'path' and 'text' properties\n* @returns {Object[]} Array of all processed chunk objects ready for embedding\n*/\nfunction processDataForPinecone(data) {\n  const allChunks = [];\n  let processedCount = 0;\n  let skippedCount = 0;\n  \n  // Process each article\n  data.forEach(article => {\n      try {\n          const chunks = cleanArticleForPinecone(article);\n          if (chunks.length > 0) {\n              allChunks.push(...chunks);\n              processedCount++;\n              console.log(`Processed article ${article.path || 'unknown'}: ${chunks.length} chunks`);\n          } else {\n              skippedCount++;\n              console.log(`Skipped empty article ${article.path || 'unknown'}`);\n          }\n      } catch (error) {\n          skippedCount++;\n          console.log(`Error processing article ${article.path || 'unknown'}: ${error.message}`);\n      }\n  });\n  \n  console.log(`\\nProcessing complete (optimized for 1024-dimension embeddings):`);\n  console.log(`- Processed articles: ${processedCount}`);\n  console.log(`- Skipped articles: ${skippedCount}`);\n  console.log(`- Total chunks created: ${allChunks.length}`);\n  \n  return allChunks;\n}\n\n// Process all items from the previous node\nconst allData = $input.first().json.allFiles\n\n// Process all collected data\nconst processedChunks = processDataForPinecone(allData);\n\n// Return the processed chunks as individual items for n8n workflow\nreturn processedChunks"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[520,120],"id":"96efe8ed-2d10-4f82-a12e-aadce081839e","name":"Clean API Docs Data"}],"connections":{"Update Knowledge Cron":{"main":[[{"node":"Github Repo Info","type":"main","index":0},{"node":"Get Articles from Intercom","type":"main","index":0}]]},"Get Articles from Intercom":{"main":[[{"node":"Clean Article Data","type":"main","index":0}]]},"Embeddings OpenAI":{"ai_embedding":[[{"node":"Pinecone Vector Store","type":"ai_embedding","index":0}]]},"Clean Article Data":{"main":[[{"node":"Pinecone Vector Store","type":"main","index":0}]]},"Recursive Character Text Splitter":{"ai_textSplitter":[[{"node":"Default Data Loader","type":"ai_textSplitter","index":0}]]},"When chat message received":{"main":[[{"node":"AI Agent","type":"main","index":0}]]},"OpenAI Chat Model":{"ai_languageModel":[[{"node":"AI Agent","type":"ai_languageModel","index":0}]]},"Simple Memory":{"ai_memory":[[{"node":"AI Agent","type":"ai_memory","index":0}]]},"Pinecone Vector Store Tool":{"ai_tool":[[{"node":"AI Agent","type":"ai_tool","index":0}]]},"Embeddings OpenAI1":{"ai_embedding":[[{"node":"Pinecone Vector Store Tool","type":"ai_embedding","index":0}]]},"Default Data Loader":{"ai_document":[[{"node":"Pinecone Vector Store","type":"ai_document","index":0}]]},"Github Repo Info":{"main":[[{"node":"Get Github Repo","type":"main","index":0}]]},"Get Github Repo":{"main":[[{"node":"Get All Files","type":"main","index":0}]]},"Get All Files":{"main":[[{"node":"Get File Content","type":"main","index":0}]]},"Get File Content":{"main":[[{"node":"Reformat Files","type":"main","index":0}]]},"Reformat Files":{"main":[[{"node":"Clean API Docs Data","type":"main","index":0}]]},"Clean API Docs Data":{"main":[[{"node":"Pinecone Vector Store","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":{"node:Update Knowledge Cron":{"recurrenceRules":[227]}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"c6e21251-e45a-4ebb-b87a-57f9b4a2c1fc","triggerCount":2,"shared":[{"createdAt":"2025-08-01T10:40:06.339Z","updatedAt":"2025-08-01T10:40:06.339Z","role":"workflow:owner","workflowId":"KrTBoSiuQw3EYkL7","projectId":"jA0J1Ydudz3t9Nad","project":{"createdAt":"2025-06-26T09:34:51.351Z","updatedAt":"2025-06-26T09:37:01.737Z","id":"jA0J1Ydudz3t9Nad","name":"Meshy AI <cloud-admins@meshy.ai>","type":"personal","icon":null,"description":null,"projectRelations":[{"createdAt":"2025-06-26T09:34:51.351Z","updatedAt":"2025-06-26T09:34:51.351Z","role":"project:personalOwner","userId":"35043bb3-1b78-4ddc-8eb1-4498c37e073f","projectId":"jA0J1Ydudz3t9Nad","user":{"createdAt":"2025-06-26T09:34:50.409Z","updatedAt":"2025-07-08T09:36:34.003Z","id":"35043bb3-1b78-4ddc-8eb1-4498c37e073f","email":"cloud-admins@meshy.ai","firstName":"Meshy","lastName":"AI","personalizationAnswers":null,"settings":{"userActivated":true,"easyAIWorkflowOnboarded":true,"firstSuccessfulWorkflowId":"5wCVdXpCNTB9yu66","userActivatedAt":1751967393973},"role":"global:owner","disabled":false,"mfaEnabled":false,"isPending":false}}]}}],"tags":[{"createdAt":"2025-07-29T08:37:45.849Z","updatedAt":"2025-07-29T08:37:45.849Z","id":"wMKqjQgGSvIDSyh5","name":"Support"}]}