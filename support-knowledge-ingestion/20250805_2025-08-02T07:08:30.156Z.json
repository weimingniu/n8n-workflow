{"createdAt":"2025-08-01T10:40:06.339Z","updatedAt":"2025-08-02T07:08:30.156Z","id":"KrTBoSiuQw3EYkL7","name":"support-knowledge-ingestion","active":false,"isArchived":false,"nodes":[{"parameters":{"rule":{"interval":[{}]}},"type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.2,"position":[-380,-80],"id":"89e89c97-8e71-4d8c-b9f2-e6ae151b3af1","name":"Update Knowledge Cron"},{"parameters":{"url":"https://api.intercom.io/articles","authentication":"predefinedCredentialType","nodeCredentialType":"intercomApi","sendQuery":true,"queryParameters":{"parameters":[{"name":"per_page","value":"200"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-160,-80],"id":"122414c9-1505-418f-8f3c-2d90dd497487","name":"Get Articles from Intercom","credentials":{"intercomApi":{"id":"Qo33N6yHJ87JjI7K","name":"Intercom account"}}},{"parameters":{"mode":"insert","pineconeIndex":{"__rl":true,"value":"n8n-support-workflow-v1","mode":"list","cachedResultName":"n8n-support-workflow-v1"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStorePinecone","typeVersion":1.3,"position":[300,-80],"id":"c166979f-979b-4b12-9cbe-56d5b826db28","name":"Pinecone Vector Store","credentials":{"pineconeApi":{"id":"Dqkxk7RFy3FsQZe8","name":"PineconeApi account for support workflow"}}},{"parameters":{"model":"text-embedding-3-large","options":{"dimensions":1024,"batchSize":30}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[240,120],"id":"0ecee326-d4bc-4f7d-8b44-e55795cc7c07","name":"Embeddings OpenAI","credentials":{"openAiApi":{"id":"iPu6knDrJFJxLQSO","name":"OpenAI account for support"}}},{"parameters":{"jsCode":"/**\n * Remove HTML tags and clean up text content.\n * \n * @param {string} htmlText - HTML content to clean\n * @returns {string} Cleaned text without HTML tags\n */\nfunction cleanHtml(htmlText) {\n    if (!htmlText) {\n        return \"\";\n    }\n    \n    // Remove HTML tags\n    let cleanText = htmlText.replace(/<[^>]+>/g, '');\n    \n    // Decode HTML entities\n    const htmlEntities = {\n        '&amp;': '&',\n        '&lt;': '<',\n        '&gt;': '>',\n        '&quot;': '\"',\n        '&#x27;': \"'\",\n        '&#x2F;': '/',\n        '&nbsp;': ' '\n    };\n    \n    for (const [entity, replacement] of Object.entries(htmlEntities)) {\n        cleanText = cleanText.replaceAll(entity, replacement);\n    }\n    \n    // Clean up whitespace\n    cleanText = cleanText.replace(/\\s+/g, ' ');\n    cleanText = cleanText.trim();\n    \n    return cleanText;\n}\n\n/**\n * Split text into overlapping chunks for better retrieval.\n * Optimized for 512-dimension embeddings with smaller chunk sizes.\n * \n * @param {string} text - Text to chunk\n * @param {number} chunkSize - Maximum size of each chunk (default: 400)\n * @param {number} overlap - Number of characters to overlap between chunks (default: 50)\n * @returns {string[]} Array of text chunks\n */\nfunction chunkText(text, chunkSize = 1000, overlap = 100) {\n    if (text.length <= chunkSize) {\n        return [text];\n    }\n    \n    const chunks = [];\n    let start = 0;\n    \n    while (start < text.length) {\n        let end = start + chunkSize;\n        \n        // If this isn't the last chunk, try to break at a sentence or word boundary\n        if (end < text.length) {\n            // Look for sentence boundary\n            const sentenceBreak = text.lastIndexOf('.', end);\n            if (sentenceBreak > start + Math.floor(chunkSize / 2)) {\n                end = sentenceBreak + 1;\n            } else {\n                // Look for word boundary\n                const wordBreak = text.lastIndexOf(' ', end);\n                if (wordBreak > start + Math.floor(chunkSize / 2)) {\n                    end = wordBreak;\n                }\n            }\n        }\n        \n        const chunk = text.slice(start, end).trim();\n        if (chunk) {\n            chunks.push(chunk);\n        }\n        \n        // Move start position with overlap\n        start = end - overlap;\n        if (start >= text.length) {\n            break;\n        }\n    }\n    \n    return chunks;\n}\n\n/**\n * Clean and format a single article for Pinecone ingestion.\n * Optimized for 512-dimension embeddings.\n * \n * @param {Object} article - Raw article data\n * @returns {string[]} Array of formatted chunks as JSON strings ready for embedding\n */\nfunction cleanArticleForPinecone(article) {\n    // Extract and clean basic fields\n    const articleId = String(article.id || '');\n    const title = (article.title || '').trim();\n    const description = (article.description || '').trim();\n    const body = cleanHtml(article.body || '');\n    const url = article.url || '';\n    \n    // Combine title, description, and body for full content\n    const fullContent = [];\n    if (title) {\n        fullContent.push(`Title: ${title}`);\n    }\n    if (description) {\n        fullContent.push(`Description: ${description}`);\n    }\n    if (body) {\n        fullContent.push(`Content: ${body}`);\n    }\n    \n    const combinedText = fullContent.join('\\n\\n');\n    \n    // Skip empty articles\n    if (!combinedText.trim()) {\n        return [];\n    }\n    \n    // Create text chunks optimized for 512-dimension embeddings (smaller chunks)\n    const chunks = chunkText(combinedText, 1000, 100);\n    \n    // Format each chunk for Pinecone and stringify\n    const formattedChunks = [];\n    \n    chunks.forEach((chunk, i) => {\n        // Create unique ID for each chunk\n        const chunkId = `${articleId}_chunk_${i}`;\n        \n        // Prepare metadata (compact for 512-dimension constraints)\n        let metadata = {\n            article_id: articleId,\n            title: title,\n            description: description,\n            url: url,\n            chunk_index: i,\n            total_chunks: chunks.length\n        };\n        \n        // Remove empty string values to reduce metadata size\n        metadata = Object.fromEntries(\n            Object.entries(metadata).filter(([key, value]) => value !== '' && !Array.isArray(value) || (Array.isArray(value) && value.length > 0))\n        );\n        \n        const formattedChunk = {\n            id: chunkId,\n            text: chunk,\n            metadata: metadata\n        };\n        \n        // Stringify the chunk object for embedding\n        formattedChunks.push(formattedChunk);\n    });\n    \n    return formattedChunks;\n}\n\n/**\n * Process the entire dataset and prepare it for Pinecone ingestion.\n * Optimized for 512-dimension embeddings.\n * \n * @param {Object[]} data - Array of raw article data\n * @returns {string[]} Array of all processed chunks as JSON strings ready for embedding\n */\nfunction processDataForPinecone(data) {\n    const allChunks = [];\n    let processedCount = 0;\n    let skippedCount = 0;\n    \n    // Process each article\n    data.forEach(article => {\n        try {\n            const chunks = cleanArticleForPinecone(article);\n            if (chunks.length > 0) {\n                allChunks.push(...chunks);\n                processedCount++;\n                console.log(`Processed article ${article.id || 'unknown'}: ${chunks.length} chunks`);\n            } else {\n                skippedCount++;\n                console.log(`Skipped empty article ${article.id || 'unknown'}`);\n            }\n        } catch (error) {\n            skippedCount++;\n            console.log(`Error processing article ${article.id || 'unknown'}: ${error.message}`);\n        }\n    });\n    \n    console.log(`\\nProcessing complete (optimized for 512-dimension embeddings):`);\n    console.log(`- Processed articles: ${processedCount}`);\n    console.log(`- Skipped articles: ${skippedCount}`);\n    console.log(`- Total chunks created: ${allChunks.length}`);\n    \n    return allChunks;\n}\n\nlet data = processDataForPinecone($input.first().json.data)\n\nreturn data"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[60,-80],"id":"0b58e977-0e8d-4a24-992d-764cbb102e3f","name":"Clean Article Data"},{"parameters":{"chunkOverlap":100,"options":{}},"type":"@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter","typeVersion":1,"position":[480,340],"id":"2b43e14b-41df-4db1-b4f9-96d13a3d038e","name":"Recursive Character Text Splitter"},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.chatTrigger","typeVersion":1.1,"position":[-740,240],"id":"fe0cd4e5-1f3b-42a5-ada2-3a79af504b39","name":"When chat message received","webhookId":"753ce490-9a7a-44c0-addf-6c5cbd1d5267"},{"parameters":{"options":{"systemMessage":"You are a helpful assistant providing answers for user support tickets for Meshy AI (www.meshy.ai). Get information of real help center articles from vector database. If you can't get accurate information, don't answer."}},"type":"@n8n/n8n-nodes-langchain.agent","typeVersion":2,"position":[-460,240],"id":"bd95c621-7bbd-489e-8b4b-48415c357f14","name":"AI Agent"},{"parameters":{"model":{"__rl":true,"value":"gpt-4.1","mode":"list","cachedResultName":"gpt-4.1"},"options":{}},"type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","typeVersion":1.2,"position":[-620,460],"id":"58734266-1154-4156-b2c3-8d6adc65f6f1","name":"OpenAI Chat Model","credentials":{"openAiApi":{"id":"iPu6knDrJFJxLQSO","name":"OpenAI account for support"}}},{"parameters":{},"type":"@n8n/n8n-nodes-langchain.memoryBufferWindow","typeVersion":1.3,"position":[-420,480],"id":"a466f8a8-1d65-444e-b116-4eb468bd6078","name":"Simple Memory"},{"parameters":{"mode":"retrieve-as-tool","toolDescription":"Get information from Meshy's help center, api docs and etc. from vector database.","pineconeIndex":{"__rl":true,"value":"n8n-support-workflow-v1","mode":"list","cachedResultName":"n8n-support-workflow-v1"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStorePinecone","typeVersion":1.3,"position":[-140,460],"id":"222041d3-a55c-4321-979b-6347dd1276bb","name":"Pinecone Vector Store Tool","credentials":{"pineconeApi":{"id":"Dqkxk7RFy3FsQZe8","name":"PineconeApi account for support workflow"}}},{"parameters":{"model":"text-embedding-3-large","options":{"dimensions":1024}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[-240,640],"id":"91a47c78-2ec7-4f6b-9d2f-7ca0b6769799","name":"Embeddings OpenAI1","credentials":{"openAiApi":{"id":"iPu6knDrJFJxLQSO","name":"OpenAI account for support"}}},{"parameters":{"jsonMode":"expressionData","jsonData":"={{ $json.text }}","textSplittingMode":"custom","options":{"metadata":{"metadataValues":[{"name":"article_id","value":"={{ $json.metadata.article_id }}"},{"name":"=title","value":"={{ $json.metadata.title }}"},{"name":"description","value":"={{ $json.metadata.description }}"},{"name":"url","value":"={{ $json.metadata.url }}"},{"name":"chunk_index","value":"={{ $json.metadata.chunk_index }}"},{"name":"total_chunks","value":"={{ $json.metadata.total_chunks }}"}]}}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1.1,"position":[500,120],"id":"aa90d682-d4e5-4722-90a2-944a75743027","name":"Default Data Loader"},{"parameters":{"content":"- Intercom Macro data link: https://app.intercom.com/ember/saved_replies.json?app_id=ipvgg8in"},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[-1060,-120],"id":"f3b0127b-8bbe-4cdb-a65c-6ea6a3b17c60","name":"Sticky Note"}],"connections":{"Update Knowledge Cron":{"main":[[{"node":"Get Articles from Intercom","type":"main","index":0}]]},"Get Articles from Intercom":{"main":[[{"node":"Clean Article Data","type":"main","index":0}]]},"Embeddings OpenAI":{"ai_embedding":[[{"node":"Pinecone Vector Store","type":"ai_embedding","index":0}]]},"Clean Article Data":{"main":[[{"node":"Pinecone Vector Store","type":"main","index":0}]]},"Recursive Character Text Splitter":{"ai_textSplitter":[[{"node":"Default Data Loader","type":"ai_textSplitter","index":0}]]},"When chat message received":{"main":[[{"node":"AI Agent","type":"main","index":0}]]},"OpenAI Chat Model":{"ai_languageModel":[[{"node":"AI Agent","type":"ai_languageModel","index":0}]]},"Simple Memory":{"ai_memory":[[{"node":"AI Agent","type":"ai_memory","index":0}]]},"Pinecone Vector Store Tool":{"ai_tool":[[{"node":"AI Agent","type":"ai_tool","index":0}]]},"Embeddings OpenAI1":{"ai_embedding":[[{"node":"Pinecone Vector Store Tool","type":"ai_embedding","index":0}]]},"Default Data Loader":{"ai_document":[[{"node":"Pinecone Vector Store","type":"ai_document","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"fed6c799-7493-4874-97d8-b803c2490aff","triggerCount":0,"shared":[{"createdAt":"2025-08-01T10:40:06.339Z","updatedAt":"2025-08-01T10:40:06.339Z","role":"workflow:owner","workflowId":"KrTBoSiuQw3EYkL7","projectId":"jA0J1Ydudz3t9Nad","project":{"createdAt":"2025-06-26T09:34:51.351Z","updatedAt":"2025-06-26T09:37:01.737Z","id":"jA0J1Ydudz3t9Nad","name":"Meshy AI <cloud-admins@meshy.ai>","type":"personal","icon":null,"description":null,"projectRelations":[{"createdAt":"2025-06-26T09:34:51.351Z","updatedAt":"2025-06-26T09:34:51.351Z","role":"project:personalOwner","userId":"35043bb3-1b78-4ddc-8eb1-4498c37e073f","projectId":"jA0J1Ydudz3t9Nad","user":{"createdAt":"2025-06-26T09:34:50.409Z","updatedAt":"2025-07-08T09:36:34.003Z","id":"35043bb3-1b78-4ddc-8eb1-4498c37e073f","email":"cloud-admins@meshy.ai","firstName":"Meshy","lastName":"AI","personalizationAnswers":null,"settings":{"userActivated":true,"easyAIWorkflowOnboarded":true,"firstSuccessfulWorkflowId":"5wCVdXpCNTB9yu66","userActivatedAt":1751967393973},"role":"global:owner","disabled":false,"mfaEnabled":false,"isPending":false}}]}}],"tags":[{"createdAt":"2025-07-29T08:37:45.849Z","updatedAt":"2025-07-29T08:37:45.849Z","id":"wMKqjQgGSvIDSyh5","name":"Support"}]}